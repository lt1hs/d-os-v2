

import { GoogleGenAI, Modality, Type, FunctionDeclaration } from "@google/genai";

if (!process.env.API_KEY) {
    throw new Error("API_KEY environment variable not set. Please set your API key for the application to function.");
}

const ai = new GoogleGenAI({ apiKey: process.env.API_KEY });

export const generateImage = async (prompt: string, aspectRatio: string): Promise<string> => {
    try {
        const response = await ai.models.generateImages({
            model: 'imagen-4.0-generate-001',
            prompt: prompt,
            config: {
                numberOfImages: 1,
                outputMimeType: 'image/jpeg',
                aspectRatio: aspectRatio as "1:1" | "3:4" | "4:3" | "9:16" | "16:9",
            },
        });

        if (response.generatedImages && response.generatedImages.length > 0) {
            const base64ImageBytes: string = response.generatedImages[0].image.imageBytes;
            return base64ImageBytes;
        } else {
            throw new Error("No image was generated by the API.");
        }
    } catch (error) {
        console.error("Error generating image with Gemini:", error);
        if (error instanceof Error) {
           if (error.message.includes('API key not valid')) {
                throw new Error('The provided API key is not valid. Please check your configuration.');
           }
           throw new Error(`Failed to generate image: ${error.message}`);
        }
        throw new Error("An unknown error occurred while generating the image.");
    }
};

export const generateVideo = async (
    prompt: string,
    aspectRatio: "16:9" | "9:16",
    resolution: "720p" | "1080p",
    onProgress: (message: string) => void
): Promise<string> => {
    try {
        // Create a new instance for each call to ensure the latest API key is used
        const videoAI = new GoogleGenAI({ apiKey: process.env.API_KEY });
        onProgress("Initializing video generation...");
        let operation = await videoAI.models.generateVideos({
            model: 'veo-3.1-fast-generate-preview',
            prompt,
            config: {
                numberOfVideos: 1,
                resolution,
                aspectRatio,
            }
        });

        onProgress("Video generation started. This may take a few minutes...");
        while (!operation.done) {
            await new Promise(resolve => setTimeout(resolve, 10000)); // Poll every 10 seconds
            onProgress("Checking video status... Hang tight!");
            operation = await videoAI.operations.getVideosOperation({ operation: operation });
        }

        onProgress("Finalizing video...");
        const downloadLink = operation.response?.generatedVideos?.[0]?.video?.uri;

        if (downloadLink) {
            return downloadLink;
        } else {
            throw new Error("Video URI not found in API response.");
        }

    } catch (error) {
        console.error("Error generating video with Gemini:", error);
        if (error instanceof Error) {
            if (error.message.includes('API key not valid') || error.message.includes('entity was not found')) {
                throw new Error('The provided API key is not valid for video generation. Please select a valid key.');
            }
            throw new Error(`Failed to generate video: ${error.message}`);
        }
        throw new Error("An unknown error occurred while generating the video.");
    }
};

export const generateFromImageAndText = async (prompt: string, imageBase64: string, mimeType: string): Promise<string> => {
    try {
        const imagePart = {
            inlineData: {
                data: imageBase64,
                mimeType: mimeType,
            },
        };
        const textPart = {
            text: prompt,
        };

        const response = await ai.models.generateContent({
            model: 'gemini-2.5-flash-image',
            contents: { parts: [imagePart, textPart] },
            config: {
                responseModalities: [Modality.IMAGE],
            },
        });

        for (const part of response.candidates[0].content.parts) {
            if (part.inlineData) {
                return part.inlineData.data;
            }
        }
        throw new Error("No image was generated in the response.");

    } catch (error) {
        console.error("Error generating from image and text with Gemini:", error);
        if (error instanceof Error) {
            if (error.message.includes('API key not valid')) {
                throw new Error('The provided API key is not valid. Please check your configuration.');
            }
            throw new Error(`Failed to edit image: ${error.message}`);
        }
        throw new Error("An unknown error occurred while editing the image.");
    }
};


export const generateDesignTemplate = async (prompt: string): Promise<any> => {
    try {
        const response = await ai.models.generateContent({
            model: 'gemini-2.5-pro',
            contents: `Generate a design layout for the following prompt. The canvas is 1080x1080. All positional and size values should be in pixels. Return only a valid JSON array of design elements. Prompt: "${prompt}"`,
            config: {
                responseMimeType: "application/json",
                responseSchema: {
                    type: Type.ARRAY,
                    items: {
                        type: Type.OBJECT,
                        properties: {
                            type: { type: Type.STRING, description: 'Type of element: "shape" or "text".' },
                            x: { type: Type.NUMBER, description: 'The x-coordinate of the top-left corner.' },
                            y: { type: Type.NUMBER, description: 'The y-coordinate of the top-left corner.' },
                            width: { type: Type.NUMBER, description: 'The width of the element.' },
                            height: { type: Type.NUMBER, description: 'The height of the element.' },
                            content: { type: Type.STRING, description: 'Text content for "text" elements.' },
                            backgroundColor: { type: Type.STRING, description: 'Hex color code for the background of a "shape".' },
                            color: { type: Type.STRING, description: 'Hex color code for the text.' },
                            fontSize: { type: Type.NUMBER, description: 'Font size in pixels for "text" elements.' },
                            fontWeight: { type: Type.STRING, description: 'Font weight (e.g., "normal", "bold").' },
                            textAlign: { type: Type.STRING, description: 'Text alignment ("left", "center", "right").' },
                            borderRadius: { type: Type.NUMBER, description: 'Border radius in pixels for "shape" elements.' },
                        },
                    },
                },
            },
        });
        
        let jsonStr = response.text.trim();
        const result = JSON.parse(jsonStr);

        if (!Array.isArray(result)) {
            console.error("API response for design template is not an array:", result);
            return [];
        }
        return result;

    } catch (error) {
        console.error("Error generating design template with Gemini:", error);
        if (error instanceof Error) {
            if (error.message.includes('API key not valid')) {
                throw new Error('The provided API key is not valid. Please check your configuration.');
            }
            throw new Error(`Failed to generate design: ${error.message}`);
        }
        throw new Error("An unknown error occurred while generating the design template.");
    }
};

export const generateSocialPost = async (prompt: string, platform: string): Promise<any> => {
    try {
        const response = await ai.models.generateContent({
            model: 'gemini-2.5-pro',
            contents: `Generate a social media post for the platform "${platform}" based on this prompt: "${prompt}". The tone should be appropriate for the platform. Include relevant hashtags and an SEO score.`,
            config: {
                responseMimeType: "application/json",
                responseSchema: {
                    type: Type.OBJECT,
                    properties: {
                        post: { type: Type.STRING, description: "The content of the social media post." },
                        hashtags: { type: Type.ARRAY, items: { type: Type.STRING }, description: "An array of suggested hashtags." },
                        seoScore: { type: Type.NUMBER, description: "An estimated SEO score from 0 to 100." },
                    },
                },
            },
        });
        let jsonStr = response.text.trim();
        return JSON.parse(jsonStr);
    } catch (error) {
        console.error("Error generating social post:", error);
        throw new Error(`Failed to generate social post: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
};

export const repurposeContent = async (content: string): Promise<any> => {
    try {
        const response = await ai.models.generateContent({
            model: 'gemini-2.5-pro',
            contents: `Repurpose the following content into multiple formats: a tweet thread, a short video script for a Reel or TikTok, a professional email, and an infographic script. Content: "${content}"`,
            config: {
                responseMimeType: "application/json",
                responseSchema: {
                    type: Type.OBJECT,
                    properties: {
                        tweetThread: { type: Type.STRING, description: "A multi-tweet thread, with tweets separated by '---'." },
                        reelScript: { type: Type.STRING, description: "A short, engaging video script for a vertical video format." },
                        email: { type: Type.STRING, description: "A professional email summarizing the content." },
                        infographicScript: { type: Type.STRING, description: "A script outlining the key points for an infographic, with sections for text and visuals." },
                    },
                },
            },
        });
        let jsonStr = response.text.trim();
        return JSON.parse(jsonStr);
    } catch (error) {
        console.error("Error repurposing content:", error);
        throw new Error(`Failed to repurpose content: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
};

export const generateBlogPost = async (topic: string): Promise<any> => {
    try {
        const response = await ai.models.generateContent({
            model: 'gemini-2.5-pro',
            contents: `Write a complete blog post about the following topic: "${topic}". The post should have a clear title, an introduction, several body paragraphs with subheadings, and a conclusion. Use markdown for formatting.`,
            config: {
                responseMimeType: "application/json",
                responseSchema: {
                    type: Type.OBJECT,
                    properties: {
                        title: { type: Type.STRING, description: "The title of the blog post." },
                        content: { type: Type.STRING, description: "The full content of the blog post in Markdown format." },
                    },
                },
            },
        });
        let jsonStr = response.text.trim();
        return JSON.parse(jsonStr);
    } catch (error) {
        console.error("Error generating blog post:", error);
        throw new Error(`Failed to generate blog post: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
};

export const generateSpeech = async (prompt: string, voice: string): Promise<string> => {
    try {
        const response = await ai.models.generateContent({
            model: "gemini-2.5-flash-preview-tts",
            contents: [{ parts: [{ text: prompt }] }],
            config: {
                responseModalities: [Modality.AUDIO],
                speechConfig: {
                    voiceConfig: {
                        prebuiltVoiceConfig: { voiceName: voice },
                    },
                },
            },
        });
        const base64Audio = response.candidates?.[0]?.content?.parts?.[0]?.inlineData?.data;
        if (base64Audio) {
            return base64Audio;
        } else {
            throw new Error("No audio data found in the API response.");
        }
    } catch (error) {
        console.error("Error generating speech with Gemini:", error);
        throw new Error(`Failed to generate speech: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
};

export const generatePodcastScript = async (topic: string, speakers: string[], style: string, duration: number): Promise<string> => {
    try {
        const response = await ai.models.generateContent({
            model: 'gemini-2.5-pro',
            contents: `Generate a podcast script.
            - Topic/Content: "${topic}"
            - Style: "${style}"
            - Desired Duration: Approximately ${duration} minutes.
            - Speakers: ${speakers.join(', ')}.

            Format the script strictly as "SPEAKER_NAME: Dialogue text", with each line of dialogue on a new line.
            Ensure the script includes a clear intro and outro suitable for the style.
            The total length should be appropriate for a ${duration}-minute podcast.`,
        });
        return response.text;
    } catch (error) {
        console.error("Error generating podcast script:", error);
        throw new Error(`Failed to generate script: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
};

export const generateMultiSpeakerSpeech = async (script: string, speakerConfigs: { speaker: string, voiceName: string }[]): Promise<string> => {
    try {
        // Fix: Add instructional prefix to the script for the TTS model.
        const ttsPrompt = `TTS the following conversation:\n\n${script}`;

        const response = await ai.models.generateContent({
            model: "gemini-2.5-flash-preview-tts",
            contents: [{ parts: [{ text: ttsPrompt }] }],
            config: {
                responseModalities: [Modality.AUDIO],
                speechConfig: {
                    multiSpeakerVoiceConfig: {
                        speakerVoiceConfigs: speakerConfigs.map(sc => ({
                            speaker: sc.speaker,
                            voiceConfig: {
                                prebuiltVoiceConfig: { voiceName: sc.voiceName }
                            }
                        }))
                    }
                }
            }
        });
        const base64Audio = response.candidates?.[0]?.content?.parts?.[0]?.inlineData?.data;
        if (base64Audio) {
            return base64Audio;
        } else {
            throw new Error("No audio data found in the API response.");
        }
    } catch (error) {
        console.error("Error generating multi-speaker speech:", error);
        throw new Error(`Failed to generate speech: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
};

export const findStockFootage = async (prompt: string): Promise<{id: string, url: string, description: string, type: 'video'}[]> => {
    // This is a mock function to simulate finding stock footage.
    // In a real application, this would call a stock footage API.
    console.log(`Searching for stock footage with prompt: "${prompt}"`);
    await new Promise(resolve => setTimeout(resolve, 1500)); // Simulate network delay
    return Promise.resolve([
        { id: `stock-${Date.now()}`, url: 'https://storage.googleapis.com/gtv-videos-bucket/sample/ForBiggerEscapes.mp4', description: 'Man walking on a beach at sunset', type: 'video' },
        { id: `stock-${Date.now()+1}`, url: 'https://storage.googleapis.com/gtv-videos-bucket/sample/BigBuckBunny.mp4', description: 'A cat sitting in a grassy meadow', type: 'video' },
        { id: `stock-${Date.now()+2}`, url: 'https://storage.googleapis.com/gtv-videos-bucket/sample/ForBiggerJoyrides.mp4', description: 'Woman doing yoga on a bridge', type: 'video' },
    ]);
};

import { SystemAction } from "../types";

export const getSystemAction = async (prompt: string): Promise<{ action: SystemAction | null; text: string | null }> => {
    const tools: FunctionDeclaration[] = [
        {
            name: 'openApp',
            description: 'Opens a specified application.',
            parameters: {
                type: Type.OBJECT,
                properties: { appId: { type: Type.STRING, description: 'The ID of the app to open (e.g., image-studio, file-explorer).' } },
                required: ['appId'],
            },
        },
        {
            name: 'closeApp',
            description: 'Closes a specified application.',
            parameters: {
                type: Type.OBJECT,
                properties: { appId: { type: Type.STRING, description: 'The ID of the app to close.' } },
                required: ['appId'],
            },
        },
        {
            name: 'minimizeApp',
            description: 'Minimizes a specified application window.',
            parameters: {
                type: Type.OBJECT,
                properties: { appId: { type: Type.STRING, description: 'The ID of the app to minimize.' } },
                required: ['appId'],
            },
        },
        {
            name: 'maximizeApp',
            description: 'Maximizes or restores a specified application window.',
            parameters: {
                type: Type.OBJECT,
                properties: { appId: { type: Type.STRING, description: 'The ID of the app to maximize or restore.' } },
                required: ['appId'],
            },
        },
        {
            name: 'createWorkspace',
            description: 'Creates a new workspace.',
            parameters: {
                type: Type.OBJECT,
                properties: { name: { type: Type.STRING, description: 'The name for the new workspace.' } },
                required: ['name'],
            },
        },
        {
            name: 'switchWorkspace',
            description: 'Switches to a workspace with a given name.',
            parameters: {
                type: Type.OBJECT,
                properties: { workspaceName: { type: Type.STRING, description: 'The name of the workspace to switch to.' } },
                required: ['workspaceName'],
            },
        },
        {
            name: 'setTheme',
            description: 'Changes the system theme.',
            parameters: {
                type: Type.OBJECT,
                properties: {
                    accentColor: { type: Type.STRING, description: 'The name of the accent color (e.g., Blue, Pink).' },
                    background: { type: Type.STRING, description: 'The name of the wallpaper (e.g., Aurora, Peaks).' },
                },
            },
        },
        {
            name: 'pinFolder',
            description: 'Pins a folder to the dock.',
            parameters: {
                type: Type.OBJECT,
                properties: { folderName: { type: Type.STRING, description: 'The name of the folder to pin.' } },
                required: ['folderName'],
            },
        },
        {
            name: 'unpinFolder',
            description: 'Unpins a folder from the dock.',
            parameters: {
                type: Type.OBJECT,
                properties: { folderName: { type: Type.STRING, description: 'The name of the folder to unpin.' } },
                required: ['folderName'],
            },
        },
        {
            name: 'lockScreen',
            description: 'Locks the system screen.',
            parameters: { type: Type.OBJECT, properties: {} },
        }
    ];

    try {
        const response = await ai.models.generateContent({
            model: 'gemini-2.5-pro',
            contents: `The user wants to perform an action in the OS. Analyze the following prompt and use the available tools. If no specific action tool is appropriate, just respond conversationally. User prompt: "${prompt}"`,
            config: {
                tools: [{ functionDeclarations: tools }],
            },
        });

        const functionCalls = response.functionCalls;
        if (functionCalls && functionCalls.length > 0) {
            const fc = functionCalls[0];
            const action: SystemAction = {
                action: fc.name as SystemAction['action'],
                payload: fc.args,
            };
            return { action, text: `Executing: ${fc.name}...` };
        } else {
            return { action: null, text: response.text };
        }
    } catch (error) {
        console.error("Error getting system action:", error);
        const errorMessage = error instanceof Error ? error.message : "An unknown error occurred.";
        return { action: null, text: `Sorry, I encountered an error: ${errorMessage}` };
    }
};